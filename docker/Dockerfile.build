# =============================================================================
#                   Red Environment - 构建环境 Dockerfile
# =============================================================================
# 用于下载和缓存所有软件，生成离线安装包
# 支持多架构构建 (amd64/x86_64 和 arm64)
# 
# 使用方法:
#   # x86_64 架构 (默认)
#   docker build -f docker/Dockerfile.build -t red_env_builder:x86_64 .
#
#   # ARM64 架构
#   docker build --platform linux/arm64 -f docker/Dockerfile.build -t red_env_builder:arm64 .
#
#   # 若需要可通过显式传入私有 token 来解除 API 速率限制（可选，不作为默认行为）
# =============================================================================

ARG BASE_IMAGE=red_env_build_base:x86_64
FROM ${BASE_IMAGE}

LABEL maintainer="Red Environment"
LABEL description="Build environment for offline terminal setup"

# 避免交互式安装
ENV DEBIAN_FRONTEND=noninteractive
ENV LANG=C.UTF-8
ENV LC_ALL=C.UTF-8

# 架构参数
ARG TARGETARCH

# 私有 token：可选，默认构建不依赖它（仅在需要时显式提供）

# -----------------------------------------------------------------------------
# 创建工作目录
# -----------------------------------------------------------------------------
WORKDIR /build

# 创建输出目录结构
RUN mkdir -p /build/output/bin \
    /build/output/cache/zim \
    /build/output/configs \
    /build/output/fonts \
    /build/output/vim_runtime

# Helper: get_version (HTTPS-only, debug output)
# Usage: /usr/local/bin/get_version owner/repo  -> prints latest tag name
COPY scripts/get_version /usr/local/bin/get_version
RUN chmod +x /usr/local/bin/get_version && \
    apt-get update && apt-get install -y musl-tools build-essential gcc pkg-config libssl-dev ca-certificates curl git && rm -rf /var/lib/apt/lists/*

# Helper: fetch_release_asset removed — use /usr/local/bin/soar_fetch_static.py for release fetching
# This repository no longer includes the legacy fetch_release_asset helper. See
# /usr/local/bin/soar_fetch_static.py which performs GitHub + pkgforge (soar) downloads
# and extracts/copies binaries into the destination directory.

# Install Soar (pkgforge client) for optional pkgforge downloads
RUN SOAR_VERSION=$(/usr/local/bin/get_version pkgforge/soar | sed 's/^v//') && \
    echo "Installing soar version: ${SOAR_VERSION}" && \
    if [ "${TARGETARCH}" = "arm64" ]; then \
        # Try direct binary first, then tarball
        if curl -fsSL "https://github.com/pkgforge/soar/releases/download/v${SOAR_VERSION}/soar-aarch64-linux" -o /usr/local/bin/soar; then :; \
        elif curl -fsSL "https://github.com/pkgforge/soar/releases/download/v${SOAR_VERSION}/soar-aarch64-linux.tar.gz" -o /tmp/soar.tar.gz && tar -xzf /tmp/soar.tar.gz -C /tmp && mv /tmp/soar-aarch64-linux /usr/local/bin/soar 2>/dev/null || true; then :; \
        else echo "[soar] install: no binary found for ${SOAR_VERSION}, skipping" >&2; fi; \
    else \
        if curl -fsSL "https://github.com/pkgforge/soar/releases/download/v${SOAR_VERSION}/soar-x86_64-linux" -o /usr/local/bin/soar; then :; \
        elif curl -fsSL "https://github.com/pkgforge/soar/releases/download/v${SOAR_VERSION}/soar-x86_64-linux.tar.gz" -o /tmp/soar.tar.gz && tar -xzf /tmp/soar.tar.gz -C /tmp && mv /tmp/soar-x86_64-linux /usr/local/bin/soar 2>/dev/null || true; then :; \
        else echo "[soar] install: no binary found for ${SOAR_VERSION}, skipping" >&2; fi; \
    fi && \
    chmod +x /usr/local/bin/soar || true

# Copy local helper scripts for fetching static releases using soar
COPY scripts/soar_fetch_static.py /usr/local/bin/soar_fetch_static.py
COPY scripts/batch_soar_fetch.py /usr/local/bin/batch_soar_fetch.py
COPY release_files/packages.json /tmp/packages.json
RUN chmod +x /usr/local/bin/soar_fetch_static.py /usr/local/bin/batch_soar_fetch.py || true


# -----------------------------------------------------------------------------
# 使用 batch_soar_fetch.py 下载 CLI 工具并扁平化到 /build/output/bin
# 该脚本会：
# 1. 批量下载所有包
# 2. 自动检测 ELF 二进制和 shebang 脚本
# 3. 组织到输出目录
# 4. 记录失败的包
# 5. 设置可执行权限
# 包列表从 release_files/packages.json 读取
# -----------------------------------------------------------------------------
RUN set -eux; \
    ARCH="$( [ "$TARGETARCH" = "arm64" ] && echo arm64 || echo x86_64 )"; \
    mkdir -p /build/output/bin; \
    python3 /usr/local/bin/batch_soar_fetch.py \
        /tmp/packages.json \
        --target-arch "$ARCH" \
        --output-dir /build/output \
        --soar-script /usr/local/bin/soar_fetch_static.py; \
    echo "=== /build/output/bin contents ==="; ls -la /build/output/bin || true



# tuios
RUN \
    TUIOS_VERSION=$(/usr/local/bin/get_version Gaurav-Gosain/tuios | sed 's/^v//') && \
    echo "Downloading tuios version: ${TUIOS_VERSION}" && \
    mkdir -p /tmp/tuios && \
    if [ "${TARGETARCH}" = "arm64" ]; then \
        curl -fsSL "https://github.com/Gaurav-Gosain/tuios/releases/download/v${TUIOS_VERSION}/tuios_${TUIOS_VERSION}_Linux_arm64.tar.gz" | tar -xz -C /tmp/tuios; \
    else \
        curl -fsSL "https://github.com/Gaurav-Gosain/tuios/releases/download/v${TUIOS_VERSION}/tuios_${TUIOS_VERSION}_Linux_x86_64.tar.gz" | tar -xz -C /tmp/tuios; \
    fi && \
    cp /tmp/tuios/tuios /build/output/bin/ && \
    rm -rf /tmp/tuios


# amix/vimrc (The Ultimate vimrc - awesome version)
RUN git clone --depth 1 https://github.com/amix/vimrc.git /build/output/vim_runtime && \
    rm -rf /build/output/vim_runtime/.git && \
    rm -rf /build/output/vim_runtime/sources_non_forked/copilot.vim && \
    chmod +x /build/output/vim_runtime/install_awesome_vimrc.sh \
        /build/output/vim_runtime/install_basic_vimrc.sh \
        /build/output/vim_runtime/install_awesome_parameterized.sh

# -----------------------------------------------------------------------------
# 代码格式化工具
# -----------------------------------------------------------------------------


# istyle-verilog-formatter (从源码静态编译)
RUN git clone --depth 1 https://github.com/thomasrussellmurphy/istyle-verilog-formatter.git /tmp/istyle && \
    cd /tmp/istyle && \
    g++ -static -O2 -o iStyle src/astyle/*.cpp src/astyle_main.cpp -I src && \
    cp iStyle /build/output/bin/ && \
    rm -rf /tmp/istyle

# uv - handled via soar_fetch_static.py (see unified fetch block)
# (Previously downloaded via curl/tar; now fetched by /usr/local/bin/soar_fetch_static.py.)

# zsh (静态编译版本，使用 romkatv/zsh-bin 的 install 脚本安装)
RUN echo "Installing zsh via romkatv/zsh-bin install script" && \
    curl -fsSL --retry 3 --retry-delay 5 -o /tmp/zsh-bin-install.sh "https://github.com/romkatv/zsh-bin/raw/refs/heads/master/install" && \
    chmod +x /tmp/zsh-bin-install.sh && \
    /tmp/zsh-bin-install.sh -q -e no -d /build/output/zsh-bin && \
    cp /build/output/zsh-bin/bin/zsh /build/output/bin/zsh && \
    mkdir -p /build/output/share && \
    cp -r /build/output/zsh-bin/share/zsh /build/output/share/ && \
    if [ -d /build/output/zsh-bin/share/terminfo ]; then \
        cp -r /build/output/zsh-bin/share/terminfo /build/output/share/; \
    fi && \
    rm -rf /build/output/zsh-bin /tmp/zsh-bin-install.sh

# -----------------------------------------------------------------------------
# 下载 Zimfw 及插件
# -----------------------------------------------------------------------------

# 下载 zimfw
RUN mkdir -p /build/output/cache/zim /build/output/cache/zim/modules && \
    curl -fsSL https://github.com/zimfw/zimfw/releases/latest/download/zimfw.zsh -o /build/output/cache/zim/zimfw.zsh

# 克隆 zimfw 模块到缓存
RUN git clone --depth 1 https://github.com/zimfw/environment.git /build/output/cache/zim/modules/environment && \
    git clone --depth 1 https://github.com/zimfw/input.git /build/output/cache/zim/modules/input && \
    git clone --depth 1 https://github.com/zimfw/utility.git /build/output/cache/zim/modules/utility && \
    git clone --depth 1 https://github.com/zimfw/git.git /build/output/cache/zim/modules/git && \
    git clone --depth 1 https://github.com/zimfw/completion.git /build/output/cache/zim/modules/completion && \
    git clone --depth 1 https://github.com/zimfw/duration-info.git /build/output/cache/zim/modules/duration-info && \
    git clone --depth 1 https://github.com/zimfw/git-info.git /build/output/cache/zim/modules/git-info && \
    git clone --depth 1 https://github.com/zimfw/asciiship.git /build/output/cache/zim/modules/asciiship && \
    git clone --depth 1 https://github.com/zsh-users/zsh-completions.git /build/output/cache/zim/modules/zsh-completions && \
    git clone --depth 1 https://github.com/zsh-users/zsh-syntax-highlighting.git /build/output/cache/zim/modules/zsh-syntax-highlighting && \
    git clone --depth 1 https://github.com/zsh-users/zsh-autosuggestions.git /build/output/cache/zim/modules/zsh-autosuggestions && \
    git clone --depth 1 https://github.com/zsh-users/zsh-history-substring-search.git /build/output/cache/zim/modules/zsh-history-substring-search && \
    git clone --depth 1 https://github.com/junegunn/fzf.git /build/output/cache/zim/modules/fzf && \
    git clone --depth 1 https://github.com/agkozak/zsh-z.git /build/output/cache/zim/modules/zsh-z && \
    git clone --depth 1 https://github.com/chrissicool/zsh-256color.git /build/output/cache/zim/modules/zsh-256color && \
    find /build/output/cache/zim/modules -type d -name .git -prune -exec rm -rf {} +

# fzf shell 支持文件
RUN git clone --depth 1 https://github.com/junegunn/fzf.git /tmp/fzf && \
    rm -rf /tmp/fzf/.git && \
    mkdir -p /build/output/cache/fzf && \
    cp -r /tmp/fzf/shell /build/output/cache/fzf/ && \
    rm -rf /tmp/fzf

# -----------------------------------------------------------------------------
# 下载字体 (Nerd Fonts) - 只保留 Regular 字体节省空间
# -----------------------------------------------------------------------------
RUN \
    FONT_VERSION=$(/usr/local/bin/get_version ryanoasis/nerd-fonts) && \
    echo "Downloading fonts version: ${FONT_VERSION}" && \
    mkdir -p /tmp/fonts && \
    curl -fsSL "https://github.com/ryanoasis/nerd-fonts/releases/download/${FONT_VERSION}/JetBrainsMono.tar.xz" -o /tmp/fonts/JetBrainsMono.tar.xz && \
    cd /tmp/fonts && tar -xJf JetBrainsMono.tar.xz && \
    cp JetBrainsMonoNerdFont-Regular.ttf /build/output/fonts/ && \
    cp JetBrainsMonoNerdFontMono-Regular.ttf /build/output/fonts/ && \
    rm -rf /tmp/fonts

# -----------------------------------------------------------------------------
# 使用 UPX 压缩二进制文件节省空间
# -----------------------------------------------------------------------------
RUN \
    UPX_VERSION=$(/usr/local/bin/get_version upx/upx | sed 's/^v//') && \
    echo "Downloading UPX version: ${UPX_VERSION}" && \
    mkdir -p /tmp/upx && \
    if [ "${TARGETARCH}" = "arm64" ]; then \
        curl -fsSL "https://github.com/upx/upx/releases/download/v${UPX_VERSION}/upx-${UPX_VERSION}-arm64_linux.tar.xz" | tar -xJ -C /tmp/upx --strip-components=1; \
    else \
        curl -fsSL "https://github.com/upx/upx/releases/download/v${UPX_VERSION}/upx-${UPX_VERSION}-amd64_linux.tar.xz" | tar -xJ -C /tmp/upx --strip-components=1; \
    fi && \
    cp /tmp/upx/upx /build/output/bin/upx && \
    chmod +x /build/output/bin/upx 
    # echo "=== Compressing binaries with UPX ===" && \
    # for bin in /build/output/bin/* /build/output/vim/bin/*; do \
    #     if [ -f "$bin" ] && file "$bin" | grep -q "ELF"; then \
    #         echo "Compressing: $(basename $bin)"; \
    #         /tmp/upx/upx --best --lzma "$bin" 2>/dev/null || echo "  Skipped (not compressible)"; \
    #     fi; \
    # done


# -----------------------------------------------------------------------------
# 确保所有二进制文件可执行
# -----------------------------------------------------------------------------
RUN chmod +x /build/output/bin/*

# 打印下载的版本信息
RUN echo "=== Downloaded Tools ===" && \
    ls -la /build/output/bin/ && \
    echo "=== Zimfw Modules ===" && \
    ls -la /build/output/cache/zim/modules/ && \
    echo "" && \
    echo "=== 静态编译验证 ===" && \
    echo "检查需要验证的二进制文件编译方式:" && \
    for binary in jq yq shfmt glow duf; do \
        if [ -f "/build/output/bin/$binary" ]; then \
            echo ""; \
            echo ">>> $binary:"; \
            file "/build/output/bin/$binary" || true; \
            echo "   ldd 检查:"; \
            ldd "/build/output/bin/$binary" 2>&1 | head -3 || echo "   (静态编译或无法检查)"; \
        fi; \
    done && \
    echo "" && \
    echo ">>> vim:"; \
    file "/build/output/vim/bin/vim" || true; \
    VIM_VERSION=$(/usr/local/bin/get_version vim/vim | sed 's/v//') && \
    if [ ! -x "/build/output/vim/bin/vim" ] && ! (grep -qE '^vim:.*:MISSING_STATIC' /build/output/DYNAMIC_EXCEPTIONS.txt 2>/dev/null); then \
        echo "vim:${VIM_VERSION}:MISSING_STATIC" >> /build/output/DYNAMIC_EXCEPTIONS.txt; \
    fi && \
    echo "vim post-check complete"

# -----------------------------------------------------------------------------
# 复制配置文件和安装脚本
# -----------------------------------------------------------------------------
COPY configs/ /build/output/configs/
COPY scripts/install.sh /build/output/install.sh
COPY scripts/uninstall.sh /build/output/uninstall.sh
RUN chmod +x /build/output/install.sh /build/output/uninstall.sh

# -----------------------------------------------------------------------------
# 生成版本信息文件
# -----------------------------------------------------------------------------
RUN echo "Red Environment Offline Package" > /build/output/version.txt && \
    echo "Build Date: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> /build/output/version.txt && \
    echo "Build Host: Docker" >> /build/output/version.txt && \
    if [ "${TARGETARCH}" = "arm64" ]; then \
        echo "Architecture: arm64" >> /build/output/version.txt; \
    else \
        echo "Architecture: x86_64" >> /build/output/version.txt; \
    fi

# -----------------------------------------------------------------------------
# 创建最终输出目录结构并打包
# 根据架构生成不同名称的压缩包
# -----------------------------------------------------------------------------
RUN mkdir -p /output && \
    if [ "${TARGETARCH}" = "arm64" ]; then \
        ARCH_NAME="arm64"; \
    else \
        ARCH_NAME="x86_64"; \
    fi && \
    mv /build/output /build/red_env_offline && \
    cd /build && \
    tar -czvf /output/red_env_offline_${ARCH_NAME}.tar.gz red_env_offline/ && \
    sha256sum /output/red_env_offline_${ARCH_NAME}.tar.gz > /output/red_env_offline_${ARCH_NAME}.tar.gz.sha256 && \
    echo "=== Final Package ===" && \
    ls -lh /output/ && \
    cat /output/red_env_offline_${ARCH_NAME}.tar.gz.sha256

# =============================================================================
# 最终阶段: 只导出 /output 目录的内容
# 使用 scratch 镜像确保 --output 只导出打包好的文件
# =============================================================================
FROM scratch AS export
COPY --from=0 /output/ /
