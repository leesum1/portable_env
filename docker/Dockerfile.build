# =============================================================================
#                   Red Environment - 构建环境 Dockerfile
# =============================================================================
# 用于下载和缓存所有软件，生成离线安装包
# 支持多架构构建 (amd64/x86_64 和 arm64)
# 
# 使用方法:
#   # x86_64 架构 (默认)
#   docker build -f docker/Dockerfile.build -t red_env_builder:x86_64 .
#
#   # ARM64 架构
#   docker build --platform linux/arm64 -f docker/Dockerfile.build -t red_env_builder:arm64 .
#
#   # 若需要可通过显式传入私有 token 来解除 API 速率限制（可选，不作为默认行为）
# =============================================================================

ARG BASE_IMAGE=red_env_build_base:x86_64
FROM ${BASE_IMAGE}

LABEL maintainer="Red Environment"
LABEL description="Build environment for offline terminal setup"

# 避免交互式安装
ENV DEBIAN_FRONTEND=noninteractive
ENV LANG=C.UTF-8
ENV LC_ALL=C.UTF-8

# 架构参数
ARG TARGETARCH

# 私有 token：可选，默认构建不依赖它（仅在需要时显式提供）

# -----------------------------------------------------------------------------
# 创建工作目录
# -----------------------------------------------------------------------------
WORKDIR /build

# 创建输出目录结构
RUN mkdir -p /build/output/bin \
    /build/output/cache/zim \
    /build/output/configs \
    /build/output/fonts \
    /build/output/vim_runtime

# Helper: get_version (HTTPS-only, debug output)
# Usage: /usr/local/bin/get_version owner/repo  -> prints latest tag name
COPY scripts/get_version /usr/local/bin/get_version
RUN chmod +x /usr/local/bin/get_version && \
    apt-get update && apt-get install -y musl-tools build-essential gcc pkg-config libssl-dev ca-certificates curl git && rm -rf /var/lib/apt/lists/*

# Helper: fetch_release_asset removed — use /usr/local/bin/soar_fetch_static.sh for release fetching
# This repository no longer includes the legacy fetch_release_asset helper. See
# /usr/local/bin/soar_fetch_static.sh which performs GitHub + pkgforge (soar) downloads
# and extracts/copies binaries into the destination directory.

# Install Soar (pkgforge client) for optional pkgforge downloads
RUN SOAR_VERSION=$(/usr/local/bin/get_version pkgforge/soar | sed 's/^v//') && \
    echo "Installing soar version: ${SOAR_VERSION}" && \
    if [ "${TARGETARCH}" = "arm64" ]; then \
        # Try direct binary first, then tarball
        if curl -fsSL "https://github.com/pkgforge/soar/releases/download/v${SOAR_VERSION}/soar-aarch64-linux" -o /usr/local/bin/soar; then :; \
        elif curl -fsSL "https://github.com/pkgforge/soar/releases/download/v${SOAR_VERSION}/soar-aarch64-linux.tar.gz" -o /tmp/soar.tar.gz && tar -xzf /tmp/soar.tar.gz -C /tmp && mv /tmp/soar-aarch64-linux /usr/local/bin/soar 2>/dev/null || true; then :; \
        else echo "[soar] install: no binary found for ${SOAR_VERSION}, skipping" >&2; fi; \
    else \
        if curl -fsSL "https://github.com/pkgforge/soar/releases/download/v${SOAR_VERSION}/soar-x86_64-linux" -o /usr/local/bin/soar; then :; \
        elif curl -fsSL "https://github.com/pkgforge/soar/releases/download/v${SOAR_VERSION}/soar-x86_64-linux.tar.gz" -o /tmp/soar.tar.gz && tar -xzf /tmp/soar.tar.gz -C /tmp && mv /tmp/soar-x86_64-linux /usr/local/bin/soar 2>/dev/null || true; then :; \
        else echo "[soar] install: no binary found for ${SOAR_VERSION}, skipping" >&2; fi; \
    fi && \
    chmod +x /usr/local/bin/soar || true

# Copy local helper script for fetching static releases using soar (Python implementation)
COPY scripts/soar_fetch_static.py /usr/local/bin/soar_fetch_static.py
RUN chmod +x /usr/local/bin/soar_fetch_static.py || true && ln -sf /usr/local/bin/soar_fetch_static.py /usr/local/bin/soar_fetch_static.sh || true


# -----------------------------------------------------------------------------
# 使用 soar_fetch_static.sh 下载 CLI 工具并扁平化到 /build/output/bin
#
# 改进: 先将每个仓库下载到独立的临时目录 (/tmp/soar_fetch/*)，
# 在所有仓库下载完毕后统一从这些目录递归查找所有可执行文件并移动到 /build/output/bin
# 这样能避免在下载过程中覆盖/冲突，并且保证“全部下载完再扁平化”的行为
# -----------------------------------------------------------------------------
RUN set -eux; \
    # 映射 TARGETARCH 到 soar_fetch_static.sh 接受的 arch 值 (x86_64|arm64)
    ARCH="$( [ "$TARGETARCH" = "arm64" ] && echo arm64 || echo x86_64 )"; \
    PACKAGES_ALL="junegunn/fzf sharkdp/bat lsd-rs/lsd BurntSushi/ripgrep sharkdp/fd dandavison/delta jesseduffield/lazygit jorgerojas26/lazysql sigoden/aichat Gaurav-Gosain/tuios ajeetdsouza/zoxide bootandy/dust ClementTsang/bottom dalance/procs chmln/sd XAMPPRocky/tokei muesli/duf jqlang/jq mikefarah/yq charmbracelet/glow sxyazi/yazi zellij-org/zellij atuinsh/atuin denisidoro/navi ouch-org/ouch pemistahl/grex astral-sh/ruff astral-sh/uv mvdan/sh JohnnyMorganz/StyLua"; \
    mkdir -p /build/output/bin /tmp/soar_fetch; \
    failures=""; \
    BASE_TMP="/tmp/soar_fetch"; \
    for repo in $PACKAGES_ALL; do \
      echo "[soar_fetch] fetching $repo for arch=$ARCH"; \
      TMPDIR=$(mktemp -d -p "$BASE_TMP" "fetch.XXXX") || TMPDIR=$(mktemp -d); \
      if /usr/local/bin/soar_fetch_static.sh "$repo" --arch "$ARCH" --dest "$TMPDIR"; then \
        echo "[soar_fetch] $repo downloaded to $TMPDIR"; \
        echo "[soar_fetch] $repo file count: $(find "$TMPDIR" -type f | wc -l)"; \
      else \
        echo "[soar_fetch] $repo failed"; failures="$failures $repo"; fi; \
    done; \
    # 打印总下载文件数以便调试
    echo "[soar_fetch] total downloaded files: $(find "$BASE_TMP" -type f | wc -l)"; \
    # 严格的一次性递归检测所有下载文件（ELF 二进制 / shebang 脚本）并搬运到 bin
    # 使用 xargs + bash 每个文件单独处理，避免 /bin/sh 不支持 read -d 的问题
    find "$BASE_TMP" -type f -print0 | xargs -0 -n1 -I{} bash -c '\
        f="$1"; \
        base=$(basename "'$'f"); \
        dest="/build/output/bin/$base"; \
        if [ -e "$dest" ]; then echo "[soar_fetch] skip existing $base"; exit 0; fi; \
        if file -L "$f" 2>/dev/null | grep -qEi "ELF"; then \
            mv -n "$f" "$dest" 2>/dev/null || cp -u "$f" "$dest" 2>/dev/null || true; \
            echo "[soar_fetch] moved binary $base"; exit 0; \
        fi; \
        if head -n 1 "$f" 2>/dev/null | grep -q "^#!"; then \
            cp -u "$f" "$dest" 2>/dev/null || true; echo "[soar_fetch] copied script $base"; exit 0; \
        fi; \
        echo "[soar_fetch] ignored $base"' _ {} ; \
    # 清理临时下载目录
    rm -rf "$BASE_TMP" || true; \
    if [ -n "$failures" ]; then echo "FAILED_FETCHES:$failures" > /build/output/FAILED_FETCHES.txt; fi; \
    if [ -f /build/output/FAILED_FETCHES.txt ]; then echo "=== FAILED_FETCHES ==="; cat /build/output/FAILED_FETCHES.txt || true; fi; \
    # Ensure binaries are executable
    chmod -R a+x /build/output/bin || true; \
    echo "=== /build/output/bin contents ==="; ls -la /build/output/bin || true


# Vim: do not attempt to fetch/build Vim binary during build (keep plugin/runtime only)
RUN \
    VIM_VERSION=$(/usr/local/bin/get_version vim/vim | sed 's/v//') && \
    echo "[vim] Skipping acquisition of Vim binary for offline package (we keep runtime/plugins only)" >&2 && \
    # Ensure an exception entry is recorded for auditing so verify recognizes the intentional omission
    echo "vim:${VIM_VERSION}:MISSING_STATIC" >> /build/output/DYNAMIC_EXCEPTIONS.txt && \
    echo "vim documented as MISSING_STATIC" && \
    :

# amix/vimrc (The Ultimate vimrc - awesome version)
RUN git clone --depth 1 https://github.com/amix/vimrc.git /build/output/vim_runtime && \
    rm -rf /build/output/vim_runtime/.git && \
    rm -rf /build/output/vim_runtime/sources_non_forked/copilot.vim && \
    chmod +x /build/output/vim_runtime/install_awesome_vimrc.sh \
        /build/output/vim_runtime/install_basic_vimrc.sh \
        /build/output/vim_runtime/install_awesome_parameterized.sh


# -----------------------------------------------------------------------------
# 代码格式化工具
# -----------------------------------------------------------------------------


# istyle-verilog-formatter (从源码静态编译)
RUN git clone --depth 1 https://github.com/thomasrussellmurphy/istyle-verilog-formatter.git /tmp/istyle && \
    cd /tmp/istyle && \
    g++ -static -O2 -o iStyle src/astyle/*.cpp src/astyle_main.cpp -I src && \
    cp iStyle /build/output/bin/ && \
    rm -rf /tmp/istyle

# uv - handled via soar_fetch_static.sh (see unified fetch block)
# (Previously downloaded via curl/tar; now fetched by /usr/local/bin/soar_fetch_static.sh.)

# zsh (静态编译版本，使用 romkatv/zsh-bin 的 install 脚本安装)
RUN echo "Installing zsh via romkatv/zsh-bin install script" && \
    curl -fsSL --retry 3 --retry-delay 5 -o /tmp/zsh-bin-install.sh "https://github.com/romkatv/zsh-bin/raw/refs/heads/master/install" && \
    chmod +x /tmp/zsh-bin-install.sh && \
    /tmp/zsh-bin-install.sh -q -e no -d /build/output/zsh-bin && \
    cp /build/output/zsh-bin/bin/zsh /build/output/bin/zsh && \
    mkdir -p /build/output/share && \
    cp -r /build/output/zsh-bin/share/zsh /build/output/share/ && \
    if [ -d /build/output/zsh-bin/share/terminfo ]; then \
        cp -r /build/output/zsh-bin/share/terminfo /build/output/share/; \
    fi && \
    rm -rf /build/output/zsh-bin /tmp/zsh-bin-install.sh

# -----------------------------------------------------------------------------
# 下载 Zimfw 及插件
# -----------------------------------------------------------------------------

# 下载 zimfw
RUN mkdir -p /build/output/cache/zim /build/output/cache/zim/modules && \
    curl -fsSL https://github.com/zimfw/zimfw/releases/latest/download/zimfw.zsh -o /build/output/cache/zim/zimfw.zsh

# 克隆 zimfw 模块到缓存
RUN git clone --depth 1 https://github.com/zimfw/environment.git /build/output/cache/zim/modules/environment && \
    git clone --depth 1 https://github.com/zimfw/input.git /build/output/cache/zim/modules/input && \
    git clone --depth 1 https://github.com/zimfw/utility.git /build/output/cache/zim/modules/utility && \
    git clone --depth 1 https://github.com/zimfw/git.git /build/output/cache/zim/modules/git && \
    git clone --depth 1 https://github.com/zimfw/completion.git /build/output/cache/zim/modules/completion && \
    git clone --depth 1 https://github.com/zimfw/duration-info.git /build/output/cache/zim/modules/duration-info && \
    git clone --depth 1 https://github.com/zimfw/git-info.git /build/output/cache/zim/modules/git-info && \
    git clone --depth 1 https://github.com/zimfw/asciiship.git /build/output/cache/zim/modules/asciiship && \
    git clone --depth 1 https://github.com/zsh-users/zsh-completions.git /build/output/cache/zim/modules/zsh-completions && \
    git clone --depth 1 https://github.com/zsh-users/zsh-syntax-highlighting.git /build/output/cache/zim/modules/zsh-syntax-highlighting && \
    git clone --depth 1 https://github.com/zsh-users/zsh-autosuggestions.git /build/output/cache/zim/modules/zsh-autosuggestions && \
    git clone --depth 1 https://github.com/zsh-users/zsh-history-substring-search.git /build/output/cache/zim/modules/zsh-history-substring-search && \
    git clone --depth 1 https://github.com/junegunn/fzf.git /build/output/cache/zim/modules/fzf && \
    git clone --depth 1 https://github.com/agkozak/zsh-z.git /build/output/cache/zim/modules/zsh-z && \
    git clone --depth 1 https://github.com/chrissicool/zsh-256color.git /build/output/cache/zim/modules/zsh-256color && \
    find /build/output/cache/zim/modules -type d -name .git -prune -exec rm -rf {} +

# fzf shell 支持文件
RUN git clone --depth 1 https://github.com/junegunn/fzf.git /tmp/fzf && \
    rm -rf /tmp/fzf/.git && \
    mkdir -p /build/output/cache/fzf && \
    cp -r /tmp/fzf/shell /build/output/cache/fzf/ && \
    rm -rf /tmp/fzf

# -----------------------------------------------------------------------------
# 下载字体 (Nerd Fonts) - 只保留 Regular 字体节省空间
# -----------------------------------------------------------------------------
RUN \
    FONT_VERSION=$(/usr/local/bin/get_version ryanoasis/nerd-fonts) && \
    echo "Downloading fonts version: ${FONT_VERSION}" && \
    mkdir -p /tmp/fonts && \
    curl -fsSL "https://github.com/ryanoasis/nerd-fonts/releases/download/${FONT_VERSION}/JetBrainsMono.tar.xz" -o /tmp/fonts/JetBrainsMono.tar.xz && \
    cd /tmp/fonts && tar -xJf JetBrainsMono.tar.xz && \
    cp JetBrainsMonoNerdFont-Regular.ttf /build/output/fonts/ && \
    cp JetBrainsMonoNerdFontMono-Regular.ttf /build/output/fonts/ && \
    rm -rf /tmp/fonts

# -----------------------------------------------------------------------------
# 使用 UPX 压缩二进制文件节省空间
# -----------------------------------------------------------------------------
RUN \
    UPX_VERSION=$(/usr/local/bin/get_version upx/upx | sed 's/^v//') && \
    echo "Downloading UPX version: ${UPX_VERSION}" && \
    mkdir -p /tmp/upx && \
    if [ "${TARGETARCH}" = "arm64" ]; then \
        curl -fsSL "https://github.com/upx/upx/releases/download/v${UPX_VERSION}/upx-${UPX_VERSION}-arm64_linux.tar.xz" | tar -xJ -C /tmp/upx --strip-components=1; \
    else \
        curl -fsSL "https://github.com/upx/upx/releases/download/v${UPX_VERSION}/upx-${UPX_VERSION}-amd64_linux.tar.xz" | tar -xJ -C /tmp/upx --strip-components=1; \
    fi && \
    cp /tmp/upx/upx /build/output/bin/upx && \
    chmod +x /build/output/bin/upx 
    # echo "=== Compressing binaries with UPX ===" && \
    # for bin in /build/output/bin/* /build/output/vim/bin/*; do \
    #     if [ -f "$bin" ] && file "$bin" | grep -q "ELF"; then \
    #         echo "Compressing: $(basename $bin)"; \
    #         /tmp/upx/upx --best --lzma "$bin" 2>/dev/null || echo "  Skipped (not compressible)"; \
    #     fi; \
    # done


# -----------------------------------------------------------------------------
# 确保所有二进制文件可执行
# -----------------------------------------------------------------------------
RUN chmod +x /build/output/bin/*

# 打印下载的版本信息
RUN echo "=== Downloaded Tools ===" && \
    ls -la /build/output/bin/ && \
    echo "=== Zimfw Modules ===" && \
    ls -la /build/output/cache/zim/modules/ && \
    echo "" && \
    echo "=== 静态编译验证 ===" && \
    echo "检查需要验证的二进制文件编译方式:" && \
    for binary in jq yq shfmt glow duf; do \
        if [ -f "/build/output/bin/$binary" ]; then \
            echo ""; \
            echo ">>> $binary:"; \
            file "/build/output/bin/$binary" || true; \
            echo "   ldd 检查:"; \
            ldd "/build/output/bin/$binary" 2>&1 | head -3 || echo "   (静态编译或无法检查)"; \
        fi; \
    done && \
    echo "" && \
    echo ">>> vim:"; \
    file "/build/output/vim/bin/vim" || true; \
    VIM_VERSION=$(/usr/local/bin/get_version vim/vim | sed 's/v//') && \
    if [ ! -x "/build/output/vim/bin/vim" ] && ! (grep -qE '^vim:.*:MISSING_STATIC' /build/output/DYNAMIC_EXCEPTIONS.txt 2>/dev/null); then \
        echo "vim:${VIM_VERSION}:MISSING_STATIC" >> /build/output/DYNAMIC_EXCEPTIONS.txt; \
    fi && \
    echo "vim post-check complete"

# -----------------------------------------------------------------------------
# 复制配置文件和安装脚本
# -----------------------------------------------------------------------------
COPY configs/ /build/output/configs/
COPY scripts/install.sh /build/output/install.sh
COPY scripts/uninstall.sh /build/output/uninstall.sh
RUN chmod +x /build/output/install.sh /build/output/uninstall.sh

# -----------------------------------------------------------------------------
# 生成版本信息文件
# -----------------------------------------------------------------------------
RUN echo "Red Environment Offline Package" > /build/output/version.txt && \
    echo "Build Date: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> /build/output/version.txt && \
    echo "Build Host: Docker" >> /build/output/version.txt && \
    if [ "${TARGETARCH}" = "arm64" ]; then \
        echo "Architecture: arm64" >> /build/output/version.txt; \
    else \
        echo "Architecture: x86_64" >> /build/output/version.txt; \
    fi

# -----------------------------------------------------------------------------
# 创建最终输出目录结构并打包
# 根据架构生成不同名称的压缩包
# -----------------------------------------------------------------------------
RUN mkdir -p /output && \
    if [ "${TARGETARCH}" = "arm64" ]; then \
        ARCH_NAME="arm64"; \
    else \
        ARCH_NAME="x86_64"; \
    fi && \
    mv /build/output /build/red_env_offline && \
    cd /build && \
    tar -czvf /output/red_env_offline_${ARCH_NAME}.tar.gz red_env_offline/ && \
    sha256sum /output/red_env_offline_${ARCH_NAME}.tar.gz > /output/red_env_offline_${ARCH_NAME}.tar.gz.sha256 && \
    echo "=== Final Package ===" && \
    ls -lh /output/ && \
    cat /output/red_env_offline_${ARCH_NAME}.tar.gz.sha256

# =============================================================================
# 最终阶段: 只导出 /output 目录的内容
# 使用 scratch 镜像确保 --output 只导出打包好的文件
# =============================================================================
FROM scratch AS export
COPY --from=0 /output/ /
